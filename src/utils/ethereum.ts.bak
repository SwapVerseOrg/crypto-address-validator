/**
 * Keccak-256 hash function for Ethereum addresses
 */
export function keccak256(data: Uint8Array): Uint8Array {
    // Simplified Keccak-256 implementation
    // For production, consider using a well-tested library

    const RC = [
        0x0000000000000001n,
        0x0000000000008082n,
        0x800000000000808an,
        0x8000000080008000n,
        0x000000000000808bn,
        0x0000000080000001n,
        0x8000000080008081n,
        0x8000000000008009n,
        0x000000000000008an,
        0x0000000000000088n,
        0x0000000080008009n,
        0x000000008000000an,
        0x000000008000808bn,
        0x800000000000008bn,
        0x8000000000008089n,
        0x8000000000008003n,
        0x8000000000008002n,
        0x8000000000000080n,
        0x000000000000800an,
        0x800000008000000an,
        0x8000000080008081n,
        0x8000000000008080n,
        0x0000000080000001n,
        0x8000000080008008n,
    ];

    const state = new Array(25).fill(0n);
    const blockSize = 136; // for Keccak-256

    let offset = 0;
    while (offset < data.length) {
        const block = Math.min(blockSize, data.length - offset);

        for (let i = 0; i < block; i++) {
            const lane = Math.floor(i / 8);
            const shift = (i % 8) * 8;
            state[lane] ^= BigInt(data[offset + i]) << BigInt(shift);
        }

        if (block === blockSize) {
            keccakF(state, RC);
        }

        offset += block;
    }

    // Padding
    const padOffset = data.length % blockSize;
    const lane = Math.floor(padOffset / 8);
    const shift = (padOffset % 8) * 8;
    state[lane] ^= 0x01n << BigInt(shift);
    state[16] ^= 0x80n << 56n;

    keccakF(state, RC);

    // Extract output
    const output = new Uint8Array(32);
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 8; j++) {
            output[i * 8 + j] = Number((state[i] >> BigInt(j * 8)) & 0xffn);
        }
    }

    return output;
}

function keccakF(state: bigint[], RC: bigint[]): void {
    for (let round = 0; round < 24; round++) {
        // Theta
        const C = new Array(5).fill(0n);
        for (let x = 0; x < 5; x++) {
            C[x] =
                state[x] ^
                state[x + 5] ^
                state[x + 10] ^
                state[x + 15] ^
                state[x + 20];
        }

        const D = new Array(5).fill(0n);
        for (let x = 0; x < 5; x++) {
            D[x] = C[(x + 4) % 5] ^ rotl(C[(x + 1) % 5], 1n);
        }

        for (let x = 0; x < 5; x++) {
            for (let y = 0; y < 5; y++) {
                state[x + y * 5] ^= D[x];
            }
        }

        // Rho and Pi
        let current = state[1];
        for (let i = 0; i < 24; i++) {
            const j = (((i + 1) * (i + 2)) / 2) % 25;
            const x = j % 5;
            const y = Math.floor(j / 5);
            const temp = state[j];
            state[j] = rotl(current, BigInt(((i + 1) * (i + 2)) / 2));
            current = temp;
        }

        // Chi
        for (let y = 0; y < 5; y++) {
            const T = new Array(5).fill(0n);
            for (let x = 0; x < 5; x++) {
                T[x] = state[x + y * 5];
            }
            for (let x = 0; x < 5; x++) {
                state[x + y * 5] = T[x] ^ (~T[(x + 1) % 5] & T[(x + 2) % 5]);
            }
        }

        // Iota
        state[0] ^= RC[round];
    }
}

function rotl(x: bigint, n: bigint): bigint {
    return ((x << n) | (x >> (64n - n))) & 0xffffffffffffffffn;
}

/**
 * Verify Ethereum address checksum (EIP-55)
 */
export function verifyEthereumChecksum(address: string): boolean {
    if (!/^0x[0-9a-fA-F]{40}$/.test(address)) return false;

    const addr = address.slice(2);
    const lowerAddr = addr.toLowerCase();

    // If all lowercase or all uppercase, checksum not required
    if (addr === lowerAddr || addr === addr.toUpperCase()) {
        return true;
    }

    const hash = keccak256(new TextEncoder().encode(lowerAddr));

    for (let i = 0; i < 40; i++) {
        const hashByte = hash[Math.floor(i / 2)];
        const hashNibble = i % 2 === 0 ? hashByte >> 4 : hashByte & 0x0f;
        const char = addr[i];

        if (hashNibble >= 8) {
            if (char !== char.toUpperCase()) return false;
        } else {
            if (char !== char.toLowerCase()) return false;
        }
    }

    return true;
}
